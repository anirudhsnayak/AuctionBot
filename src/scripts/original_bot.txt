# -*- coding: utf-8 -*-
"""
Created on Fri Jul  2 16:23:23 2021

@author: nayak
"""
#!!! CREATE A WAY TO CHECK FOR FAKE FLIPS 
#(all auctions before are less than the checked auction.)
#This may require a threshold, but idk
'''
NOTE:
    Basically, what this does is check the apparent price of an item (the consumer value), 
    and ranks it based on other items of the same type. (This can either be done all at once
    by just sorting the list, or simply by checking each item consecutively). Given this ranking, 
    an item can be determined to be valued within a price range of two other items. Then, 
    the price difference between the current BIN offer and the lowest bin offer of the price range 
    is tested, and printed to the user if it surpasses a certain threshold. Note that this 
    only covers BIN-to-BIN flipping, and that too for certain pre-defined items. The other 
    major methods are level flipping, upgrade flipping, craft flipping, and regular auction
    flipping. Bazaar flipping is trash lmfao. Level flipping can be done by evaluating the 
    difference in pet/expertise/compact level and seeing whether it's worth it to either use
    candies or manually level by running simulations on the upgraded variants, with margins 
    adjusted accordingly (manual levelling can be approximated for a monetary value). However,
    it's probably just better to not have the bot do this and just manually look for these 
    flips, since many other AH flippers tend to ignore these. Upgrade flipping is the same 
    case. Run simulations on the upgrade to see where it would land, adjust the margins 
    accordingly. Note that these do require more computer power, but given the API limits 
    (0.5 sec ;-;) it shouldn't be too hard. Craft flipping is a variant of upgrade flipping,
    but considers items as a whole rather than individual upgrades. This is probably best to
    just run a lowest bin calculator on a lot of different recipes to see which work. (Most
    craft flips typically use mostly Bazaar prices, so this bot is practically useless for 
    those. Make a new bot.) Regular auction flipping is interesting. The best way to do it 
    might be just to track snipes (<2 min going for lowballs), since that's what most 
    flippers do. Since this is applied to individual items, level/upgrade flipping simulations
    can be run on them to see if that would lead to a profit increase. Finally, AH flipping
    can be done in advance (think >30min-1hr), to lead to near margin flips. However, this 
    is really not profitable, and can still be taken by people who don't want to flip. 
    If you're ever doing it, just do it manually tbh.
'''

import requests;
import time;
import numpy as np;
import sys;
import pyperclip;

#Probably should have another list of pet skins in order to enable/disable them at will.
commodityWatchlist = ["Krampus Helmet", "Ultimate Carrot Candy Upgrade", "Jumbo Backpack Upgrade", "Enrichment", "Chimera I", "Pristine V", "Pristine I", "Soul Eater I",
                      "Autopet Rules", "French Bread", "Pioneer Pickaxe",  "Gorilla Monkey", "XX-Large Storage", "Tier Boost", "Beacon V", "Beacon IV", "Beacon III", "Beacon II", 
                      "Infinityboom TNT", "Flycatcher", "Pumpkin Launcher", "Lucky Clover", "Lesser Soulflow Engine", "Ancient Rose", "Reforge Anvil", "Exp Share", "Exp Share Core", "Enchanted Hopper", 
                      "Soul Esoward", "Large Storage", "Weird Tuba", "Ultimate Carrot Candy", "Twilight Tiger Skin", "Spirit Skin", "Radiant Enderman Skin", "Void Conqueror Skin",
                      "Judgement Core", "Jungle Heart", "Plasmaflux Power Orb", "Warden Heart", "Plasma Nucleus", "Icicle Skin", "Neon Blue Ender Dragon Skin", "Exceedingly Rare Ender Artifact Upgrader",
                      "Null Blade", "Overflux Power Orb", "!LEGENDARY Griffin Upgrade Stone", "Black Widow Skin", "Reinforced Skin", "Pufferfish Skin", "Golden Monkey Skin", "Royal Pigeon", "Neon Red Ender Dragon Skin",
                      "Shard of the Shredded", "Vampire Fang", "Scythe Shard", "Pastel Ender Dragon Skin", "Reaper Gem", "Washed-up Souvenir", "Wood Singularity", "Tesselated Ender Pearl", "Corleonite", "Diamante\u0027s Handle",
                      "Necron\u0027s Handle", "Grown-up Baby Yeti Skin", "Wither Blood", "Precursor Gear", "Block Zapper", "Builder\u0027s Wand", "Overflux Capacitor", "Snowglobe Skin",
                      "First Master Star", "Second Master Star", "Third Master Star", "Fourth Master Star", "Soulflow Engine", "Minos Relic", "Enderpack Skin", "Watcher Guardian Skin", "Braided Griffin Feather",
                      "Fossilized Silverfish Skin", "Silex", "Purple Egged Skin", "Green Egged Skin", "Orca Blue Whale Skin", "Zombie Skeleton Horse Skin", "Mauve Skin", "Admiral Skin", "Dragon Horn", "Null Edge", "Crimson Skin"
                      "Dwarf Turtle Shelmet", "Deep Sea Orb", "Monochrome Elephant Skin", "Dragon Claw", "Dragon Scale", "Recall Potion", "Spirit Bone", "Spirit Wing", "Personal Harp", "Lucky Dice", "Sadan\u0027s Brooch"
                      "Cool Rock Skin", "Laughing Rock Skin", "Thinking Rock Skin", "Summoning Ring", "Blue Elephant Skin", "Perfectly-Cut Fuel Tank", "Amber-polished Drill Engine", "Derpy Rock Skin", "Embarrassed Rock Skin",
                      "Smiling Rock Skin", "Pink Elephant Skin", "Gemstone Mixture", "Mithril Plate", "Golden Plate", "Gemstone Fuel Tank", "Orange Elephant Skin", "Neon Red Sheep Skin", "Neon Blue Sheep Skin", "Titanium-plated Drill Engine", 
                      "Jaderald", "Purple Elephant Skin", "Red Elephant Skin", "Puppy Skin", "Green Elephant Skin", "Warped Stone", "Mana Flux Power Orb", "White Sheep Skin", "Pink Sheep Skin", "Black Sheep Skin", "Red Sheep Skin", "Purple Sheep Skin"
                      "Light Blue Sheep Skin", "Onyx Black Cat Skin", "Light Green Sheep Skin", "Warden Heart"]

talismanWatchlist = ["Personal Compactor 7000", "Personal Compactor 6000", "Bat Artifact", "Golden Jerry Artifact", "Hegemony Artifact", "Candy Relic", "Reaper Orb", "Scarf\u0027s Grimoire", "Treasure Artifact", "Razor-sharp Shark Tooth Necklace", 
                     "!MYTHIC Beastmaster Crest", "!LEGENDARY Beastmaster Crest", "!EPIC Beastmaster Crest", "Wither Relic", "Auto Recombobulator", "Titanium Relic", "Seal of the Family", "Ender Artifact", "Wither Artifact", "Ender Relic", 
                     "Spider Artifact", "Treasure Ring", "Catacombs Expert Ring", "Red Claw Artifact", "Spiked Atrocity", "Experience Artifact", "Soulflow Supercell", "Tarantula Talisman", "Hunter Ring", "Purple Jerry Talisman", "Bait Ring",
                     "Survivor Cube", "Zombie Artifact", "Speed Artifact", "Devour Ring", "Wolf Ring", "Intimidation Artifact", "Frozen Chicken", "Bits Talisman", "Eternal Hoof", "Soulflow Battery", "Bat Person Artifact", "Blue Jerry Talisman",
                     "Titanium Ring", "Sea Creature Artifact", "Personal Compactor 5000", "Mineral Talisman", "Red Claw Ring", "Scarf\u0027s Studies",  "Scarf\u0027s Thesis", "Fish Affinity Talisman", "Potion Affinity Artifact", "Feather Artifact",
                     "Haste Ring", "Crab Hat of Celebration", "Blood God Crest", "Potato Talisman", "Handy Blood Chalice", "Pocket Espresso Machine", "Jungle Amulet", "Hunter Talisman", "Wolf Paw"]

#MODIFIED ITEMS (Stars, Frag Upgrades) GO BEFORE NON-MODFIED ITEMS
upgradableWatchlist = ["Storm\u0027s Boots ✪✪✪✪✪", "Necron\u0027s Boots ✪✪✪✪✪", "Goldor\u0027s Boots ✪✪✪✪✪", 
             "Storm\u0027s Leggings ✪✪✪✪✪", "Necron\u0027s Leggings ✪✪✪✪✪", "Goldor\u0027s Leggings ✪✪✪✪✪"
             "Storm\u0027s Chestplate ✪✪✪✪✪", "Necron\u0027s Chestplate ✪✪✪✪✪", "Goldor\u0027s Chestplate ✪✪✪✪✪"
             "Livid Dagger ✪✪✪✪✪", "Flower of Truth ✪✪✪✪✪", "Reaper Mask ✪✪✪✪✪", "!LEGENDARY Blue Whale", 
             "!LEGENDARY Elephant", "Axe of the Shredded ✪✪✪✪✪", "!LEGENDARY Black Cat", "Shadow Assassin Chestplate ✪✪✪✪✪", "!EPIC Tiger",
             "!LEGENDARY Tiger", "Rod of the Sea", "Juju Shortbow ✪✪✪✪✪", "Wand of Atonement", "Vorpal Katana", "Wither Goggles ✪✪✪✪✪",
             "!LEGENDARY Baby Yeti", "!EPIC Baby Yeti", "!LEGENDARY Squid", "!LEGENDARY Flying Fish", "!LEGENDARY Lion", "Warden Helmet", "Atomsplit Katana"]
^^^^^^^^^^^^^^^^^^^
watchlist = talismanWatchlist+upgradableWatchlist+commodityWatchlist;
profitTable = [];
auctionCache = [];
BINAuctionWatchlistCache = {};
REGAuctionWatchlistCache = {};
updateRate = 45; #Seconds
m = 1000000;
k = 1000;
petRarities = {"COMMON", "UNCOMMON", "RARE", "EPIC", "LEGENDARY", "MYTHIC"}
petMultiplierTable = {"!LEGENDARY Wolf":7, "!LEGENDARY Sheep":3, "!LEGENDARY Blue Whale":24, "!LEGENDARY Dolphin":20, 
 "!EPIC Dolphin":9, "!EPIC Tiger":10, "LEGENDARY Tiger": 13, "!LEGENDARY Spider": 34, "!LEGENDARY Tarantula": 19,
 "!LEGENDARY Elephant": 8, "!MYTHIC Bat":2, "!LEGENDARY Bat":5, "!LEGENDARY Ender Dragon":13, "!LEGENDARY Black Cat": 26,
 "!LEGENDARY Baby Yeti": 22, "!EPIC Baby Yeti":7, "!LEGENDARY Squid":10, "!LEGENDARY Flying Fish": 18, "!LEGENDARY Lion": 24
 } #Mil Difference between 0 and 100
petLoreValueTable = {"Minos Relic": 30*m, "Dwarf Turtle Shelmet": 2*m}
loreValueTable = {"§k":5*m, "Rejuvenate V":500*k, "Legion I":1*m, "Legion II":2*m, 
 "Legion III":4*m,"Legion IV":7*m, "Legion V":13*m, "Wisdom I":100*k,
 "Wisdom II":300*k, "Wisdom III":600*k, "Wisdom IV": 1.5*m, "Wisdom V": 2*m,
 "Growth VI": 2.1*m, "Protection VI": 2.1*m, "Protection V":1, "Growth V":1, "Soul Eater I": 1.19*m, 
 "Soul Eater II": 2.7*m, "Soul Eater III": 5.54*m, "Soul Eater IV": 11.4 *m, "Soul Eater V": 21.7*m,
 "Ultimate Wise I": 100*k, "Ultimate Wise II": 270*k, "Ultimate Wise III": 600*k, 
 "Ultimate Wise IV": 1.4*m, "Ultimate Wise V": 2.5*m, "§e(+20)": 300*k, "One For All": 8*m}
loreOverrideTable = {"Growth VI": 0, "Protection VI":0} #Settings
#Growth/Prot 1 coin is to prevent fake flips. Can be increased if necessary.

def getEnchantmentLevel(lore, enchantment):
    if not(enchantment in lore):
        return 0;
    levelIndex = lore.find(enchantment)+len(enchantment)+1;
    levelValue = 0;
    for char in lore[levelIndex:levelIndex+5]: #all enchantments are at most VIII
        #Switch here?    
        if (char == 'I'):
            levelValue+=1;
        elif (char == 'X'):
            if (levelValue > 0):
                return 10-levelValue;
            else:
                levelValue+=10;
        elif (char == 'V'):
            if (levelValue > 0):
                return 5-levelValue;
            else:
                levelValue+=5;
        elif (char == ' '):
            return levelValue
        
def getItemReforgeValue(name, tier):
    reforgeValue = 0; 
    if ("Withered" in name):
        reforgeValue += 2100000;
    if ("Ancient" in name):
        reforgeValue += 600000;     
    if ("Necrotic" in name):
        reforgeValue += 300000;
    return reforgeValue; #APPARENT Value (not craft cost)  

def getItemLoreValue(lore):
    loreValue = 0;
    for key in loreValueTable.keys():
        if (key in lore):
            if (key in loreOverrideTable.keys()):
                loreValue+=loreOverrideTable[key];
            else:    
                loreValue+=loreValueTable[key];
    return loreValue; #APPARENT Value (not craft cost)

def getPetSkillTypeMultiplier(petName):
     for key in petMultiplierTable.keys():
        if (key in petName):
           return petMultiplierTable[key];
                
def getPetApparentValue(pet):
    name = pet["item_name"];
    lore = pet["item_lore"];
    rarity = pet["tier"];
    skillMultiplier = getPetSkillTypeMultiplier("!"+rarity+" "+name[name.find("]")+2:] )
    level = int(name[name.find("Lvl")+4:name.find("]")] )
    petBaseWorth = skillMultiplier*np.exp2(level/5); #not that great of a solution, but whatever
    for key in petLoreValueTable.keys():
        if (key in lore):
           petBaseWorth+=petLoreValueTable[key];
    return petBaseWorth;
    
def getApparentValue(item):
    if ("Lvl" in item["item_name"]):
        return getPetApparentValue(item)
    reforgeValue = getItemReforgeValue(item["item_name"], item["tier"]);
    loreValue = getItemLoreValue(item["item_lore"]);
    return reforgeValue+loreValue;

def getAuctionsByItemName(auctions, name, BIN):
    if(BIN):
        return BINAuctionWatchlistCache[name];
    else:
        auctionUUIDs = [];
        deletedUUIDs = [];
        auctions = REGAuctionWatchlistCache[name];
        for auction in auctions:
            auctionUUIDs.append(auction['uuid'])
            if(auction["end"]-int(time.time())<=900): #15 minutes
                auctionUUIDs.append(auction['uuid'])
            else:
                deletedUUIDs.append(auction['uuid'])
        for auction in auctions.copy():
            if auction['uuid'] in deletedUUIDs:
                auctions.remove(auction);
        return auctions, auctionUUIDs;

def sortAuctionsByPrice(itemAuctions):
    return sorted(itemAuctions, key= lambda i: i["starting_bid"]);  
def sortAuctionsByTime(itemAuctions): #For AH Sniping
    return sorted(itemAuctions, key= lambda i: i["end"]);  

def getBuyPrice(item):
    if (item["bin"]): 
        return item["starting_bid"];
    else:
        return item["highest_bid_amount"];
    
def getEstimatedFlipMargins(auctionPlaces):
    apparentValues = [];
    minimumMargins = {};
    maximumMargins = {};
    for item in auctionPlaces:
        apparentValues.append(getApparentValue(item));  
    for i in range(len(auctionPlaces)):
        j=i; 
        item = auctionPlaces[i];
        minApparentDifference = apparentValues[i];
        minFlipValue = 0;
        while (True):
            j+=1;
            if (j==len(auctionPlaces)):
                minimumMargins[item["uuid"]]= getBuyPrice(auctionPlaces[j-1])-1.02*getBuyPrice(item);
                maximumMargins[item["uuid"]] = 'max';
                break;
            if(apparentValues[i]<=apparentValues[j]):
                minimumMargins[item["uuid"]] = minFlipValue;
                maximumMargins[item["uuid"]] = getBuyPrice(auctionPlaces[j])-1.02*getBuyPrice(item);
                break;
            elif (minApparentDifference>apparentValues[i]-apparentValues[j]):
                minApparentDifference = apparentValues[i]-apparentValues[j];
                minFlipValue = getBuyPrice(auctionPlaces[j])-1.02*getBuyPrice(item);
    return minimumMargins, maximumMargins;
  
def refreshAuctions(maxAHPages=999):
    global auctionCache;
    for watchlistItem in watchlist:
        BINAuctionWatchlistCache[watchlistItem] = [];
        REGAuctionWatchlistCache[watchlistItem] = [];
    
def findUpgradableFlips(itemName):
    global auctionCache;
    itemAuctions=getAuctionsByItemName(auctionCache, itemName, True);
    endingAuctions, auctionUUIDs = getAuctionsByItemName(auctionCache, itemName, False);
    itemAuctions = sortAuctionsByPrice(itemAuctions+endingAuctions) 
    #Basically you would append your modified item/items into the item auctions, and then proceed to run the
    #estimated flip margin simulation (Set ["starting_bid"] higher by the amount needed to upgrade the item. 
    #This should allow for craft/upgrade flipping to be calculated for.
    minimumProfits, maximumProfits = getEstimatedFlipMargins(itemAuctions);
    sortedProfits = dict(sorted(minimumProfits.items(), key=lambda item: item[1], reverse=True));
    return sortedProfits, auctionUUIDs;
def findTalismanFlips(itemName):
    global auctionCache;
    itemAuctions=getAuctionsByItemName(auctionCache, itemName, True);
    endingAuctions, auctionUUIDs = getAuctionsByItemName(auctionCache, itemName, False);
    itemAuctions = sortAuctionsByPrice(itemAuctions+endingAuctions);
    recombItems = []; plainItems = [];
    for item in itemAuctions:
        if "§k" in item["item_lore"]:
            recombItems.append(item);
        else:
            plainItems.append(item);
    flips = {};
    if(len(recombItems)>=2):
        flips[recombItems[0]["uuid"]]=getBuyPrice(recombItems[1])-1.02*getBuyPrice(recombItems[0]);
    if(len(plainItems)>=2):
        flips[plainItems[0]["uuid"]]=getBuyPrice(plainItems[1])-1.02*getBuyPrice(plainItems[0]);
    return flips, auctionUUIDs;
def findCommodityFlips(itemName):
    global auctionCache;
    itemAuctions=getAuctionsByItemName(auctionCache, itemName, True);
    endingAuctions, auctionUUIDs = getAuctionsByItemName(auctionCache, itemName, False);
    itemAuctions = sortAuctionsByPrice(itemAuctions+endingAuctions);
    flips = {};
    if(len(itemAuctions)>=2):
        flips[itemAuctions[0]["uuid"]]=getBuyPrice(itemAuctions[1])-1.02*getBuyPrice(itemAuctions[0]);
    return flips, auctionUUIDs;    
def findFlips(itemName):
    
    for baseItem in upgradableWatchlist:
        if baseItem in itemName:
            return findUpgradableFlips(itemName);
    for baseItem in talismanWatchlist:
        if baseItem in itemName:
            return findTalismanFlips(itemName);
    for baseItem in commodityWatchlist:
        if baseItem in itemName:
            return findCommodityFlips(itemName);
    return [];
def getItemModifiers(itemName):
    modifiers = {};
    if(itemName[0]=='!'):
            modifiers["rarity"]= itemName[1:itemName.find(" ")];
            itemName=itemName[itemName.find(" ")+1:]
    return modifiers, itemName;   
def checkItemInWatchlist(item):
    global watchlist;
    for name in watchlist:
        modifiers, baseName = getItemModifiers(name);
        rarity = "";
        if("rarity" in modifiers.keys()):
            rarity = modifiers["rarity"];
        if (baseName in item["item_name"]):
            if("✪" in item["item_name"] and not ("✪" in baseName)):
                continue; #Differentiate between 5 Starred and 0 Starred (TODO: Create separate differentiation for other star #)
            if(rarity!=""):
                if(rarity==item["tier"] and not ("Tier Boost" in item["item_lore"])): #TODO: Create a way to convert between rarities
                    return name;
            else:
                return name;
    return -1;        

def main():  
    thresh = 10000;
    auctions ={}
    for item in watchlist:
        profits, auctionUUIDs = findFlips(item)
        for uuid in profits.keys():
            if(profits[uuid]<thresh):
                continue;
            if not(uuid in profitTable):
                profitTable.append(uuid);
                if(uuid in auctionUUIDs):
                    print("Snipe Found! " + "{:,}".format(profits[uuid])+ " /viewauction "+uuid);
                else:
                    print("Flip Found! " + "{:,}".format(profits[uuid])+ " /viewauction "+uuid);
                auctions[uuid]=profits[uuid];
    return auctions;
        
import pygame
import pygame_gui

MAX_ROW_SIZE=3
AUCTION_PX_X=800/MAX_ROW_SIZE
AUCTION_PX_Y=100

pygame.init()

pygame.display.set_caption('Auction Flipper')
window_surface = pygame.display.set_mode((800, 600))

background = pygame.Surface((800, 600))
background.fill(pygame.Color('#000000'))

manager = pygame_gui.UIManager((800, 600))


time_ = 0;
queryAuctions = False;
totalPages = 0;
currentPage = 0;

auctions = {};
def clearPastFlips():
    global auctions
    for flipButton in auctions.keys():
        flipButton.kill();
    auctions = {};
    
def createFlipDisplay(profits, uuid):
    flipNum = len(auctions.keys())
    x = flipNum%MAX_ROW_SIZE 
    y = (flipNum-x)/MAX_ROW_SIZE 
    xScaled = AUCTION_PX_X*x
    yScaled = AUCTION_PX_Y*y
    panel = pygame_gui.elements.ui_panel.UIContainer(relative_rect=pygame.Rect((xScaled, yScaled), (xScaled+AUCTION_PX_X, yScaled+AUCTION_PX_Y)), manager=manager)
    button=pygame_gui.elements.UIButton(relative_rect=pygame.Rect(((0), 0), (AUCTION_PX_X, AUCTION_PX_Y)),
                                            text="{:,}".format(profits),
                                            manager=manager, container=panel, tool_tip_text='Click to Copy Auction')
    auctions[button]=uuid

clock = pygame.time.Clock()
is_running = True

while is_running:
    time_delta = clock.tick(60)/1000.0
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            is_running = False

        if event.type == pygame.USEREVENT:
            if event.user_type == pygame_gui.UI_BUTTON_PRESSED:
                if event.ui_element in auctions.keys():
                    pyperclip.copy("/viewauction " + auctions[event.ui_element])
                    print("") #newline
                    print("Copied!")
                     
        manager.process_events(event)
    
   
    if(queryAuctions):
        try:
            auctionCache = requests.get("https://api.hypixel.net/skyblock/auctions?page="+str(currentPage)).json()["auctions"];
        except KeyError:
            print("There was an error with the auction house. Retrying...")
            time.sleep(5);
        for item in auctionCache:
            name = checkItemInWatchlist(item);
            if (name!=-1):
                if('bin' in item):
                    BINAuctionWatchlistCache[name].append(item);
                else:
                    REGAuctionWatchlistCache[name].append(item);    
        print(currentPage)
        currentPage+=1;
        if(currentPage==totalPages):
            print("Refreshed!");
            currentPage=0;
            time_ = updateRate+1; #scuffed flag
            
    else:  
        time_ += time_delta;
        sys.stdout.write("\r" + str(100*float(time_)/float(updateRate))+"%")
        sys.stdout.flush()

    if (time_>updateRate):
        if(queryAuctions):
            print("")
            flips = None;
            try:
                flips = main();
            except KeyError:
                print("There was an error with the auction house. Retrying...")
                time.sleep(5);
            clearPastFlips()    
            for uuid in flips:
                createFlipDisplay(flips[uuid], uuid)
            time_ = 0;
            queryAuctions = False;
        else:
            queryAuctions = True;
            try:
                totalPages = requests.get("https://api.hypixel.net/skyblock/auctions?page=0").json()["totalPages"];
            except KeyError:
                print("There was an error with the auction house. Retrying...")
                time.sleep(5);
            time_= 0;  #scuffed flag
            refreshAuctions();

    manager.update(time_delta)

    window_surface.blit(background, (0, 0))
    manager.draw_ui(window_surface)

    pygame.display.update()
pygame.quit()